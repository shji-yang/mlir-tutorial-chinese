translate from https://jeremykun.com/2023/08/10/mlir-running-and-testing-a-lowering/

方言(dialects)和降维(lowerings)是 MLIR 的两个核心概念。它们是脚手架，我们可以在其中完成编译器中真正有趣的部分，即优化和分析。在传统编译器中，通常有一种 "方言(dialects)"（称为中间表示或 IR），它是编译器代码中程序的文本或数据结构描述。例如，在 GCC 中，IR 被称为 GIMPLE，而在 LLVM 中，它被称为 LLVM-IR。它们将输入程序转换为 IR，进行优化，然后将优化后的 IR 转换为机器代码。

在 MLIR 中，我们将工作分成更小的步骤。首先，MLIR 允许定义多种方言，有些被认为是 "高级 "方言，有些则是 "低级 "方言，但每种方言都有一套类型、操作、元数据和语义来定义操作的内容。然后，我们要编写一组降低传递，逐步将程序的不同部分从较高层次的方言转换为越来越低的方言，直至转换为机器代码（或者，在许多情况下，转换为 LLVM，从而完成这项工作）。在此过程中，程序会进行优化，以提高代码的效率。这里的重点是，高级方言的存在是为了方便编写这些重要的优化传递。降低传递和优化传递之间并没有特殊的区别，它们在 MLIR 中都被称为传递，都是通用的 IR 重写模块。

**题外话** 据我所知，MLIR 的一个重要动机是构建 affine 方言，该方言专门用于对循环变换进行多面体优化，同时还构建了 linalg 方言，该方言可以在专用硬件上对底层 ML 操作进行平铺等优化。人们在 LLVM 和 GCC（不使用仿射）中构建了多面体优化，但这是一件非常麻烦的事，主要是因为他们必须处理一塌糊涂的低级分支和 GOTO，并尝试从中重建一个简单（"仿射"）的 for 循环结构。即使输入程序是一组简单的 for 循环，也必须这样做，因为当他们进入编译器时，僵化的 for 循环结构已经被丢弃了。而 MLIR 则表示，将结构保留在高级方言中，在那里进行优化，然后在转到低级方言时将其丢弃。

# Two example programs
要正确理解一般知识，首先要举出具体的例子。下面是两个 MLIR 程序，它们定义了一个计算 32 位整数 (i32) 前导零点的函数。第一个程序使用数学方言定义的 ctlz 操作并直接返回。
```
func.func @main(%arg0: i32) -> i32 {
  %0 = math.ctlz %arg0 : i32
  func.return %0 : i32
}
```